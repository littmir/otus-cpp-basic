## Explicit-конструкторы

Стандартные типы могут неявно конвертироваться друг в друга.  
Также, неявно могут конвертироваться стандартные типы в пользовательские, если входной аргумент соответствует.

**Explicit** перед конструктором говорит о том, что неявное преобразование для этого конструктора запрещено.

В критичных местах лучше  использовать пользовательские типы и explicit, чтобы при написании кода компилятор нас вынуждал объявлять конкретные типы и передавать в функции так же конкретные типы, а не абстрактные числа. Это приводит к снижению вероятности ошибки.

Неявное преобразование практически невозможно при передаче в функцию двух параметров. Исключение - если все, кроме одного аргумента, заданы по умолчанию.

Explicit копирующий конструктор почти всегда моветон.

Explicit имеет смысл для конструкторов с обязательным аргументом.

## Перегрузка

Лучше перегружать сложение как свободную функцию.

Перегрузка: =, [], () - только методы класса.  
Остальные - свободные функции. 

## Конструктор копирования

Если самостоятельно не определен конструктор копирования, то компилятор сгенерирует его зна нас.

**Правило трёх** - если написан деструктор или конструктор копирования или оператор присваивания, то скорее всего все три эти элемента нужны одновременно.

Если есть собственный деструктор, который освобождает память, то скорее всего, те конструкторы копирования, которые сгенерировал компилятор нас не устроили, и скорее всего, там двойное освобождение памяти.

Если нет хорошего способа написать **конструктор копировани**я, можно его **запретить**.

```C++
Complex(const Complex &other) = delete;
```

Этим сообщается компилятору, чтобы он не создавал конструктор копирования.

```C++
Complex(const Complex &other) = default;
```

Приведённый выше код, показывает читателю кода, что используется генерация конструктора копирования от компилятора. 

Конструктор копирования является **нешаболнным** и принимает в качестве аргумента ссылку на объект этого же класса.

**Шаблонный** конструктор никогда не является конструктором копирования, и компилятор все равно будет генерировать свой конструктор.

Оператор **"="** - это конструктор копирования.

## Виртуальность

**Нельзя** написать класс, который содержит **виртуальный шаблонный метод**.

**Виртуальный метод никогда не может быть шаблонным.**

**Может быть виртуальный класс с шаблонной функцией.**

Для классов, для которых планируются наследники, нужно всегда писать виртуальный деструктор.  
Это нудно, чтобы вызывался деструктор класса наследника, а потом деструктор базового класса, иначе undefined behavior.  
Либо, вызывая деструктор, нужно явно кастоваться к классу, деструктор которого вызывается.

Спецификатор класса **final** говорит о том, что от него нельзя отнаследоваться.

## Move-семантика

Когда нудно вытащит всё из объекта, и сам объект больше не нужен, тогда используется move-семантика.

Вызов функции всегда **rvalue**.

Пока rvalue не преобразовалось в lvalue, нет никакого способа узнать его значение.

У rvalue нельзя взять адрес.

Move-семантика нужна исключительно для оптимизации.

Перемещающий конструктор принимает rvalue, и так как никто не знает содержание rvalue кроме нас, то его можно изменять как угодно, ведь как только закончится выражение, его не станет.

```C++
DynamicString(DynamicString &&other) {
  m_data = other.m_data;
  other.m_data = nullptr;
  m_size = other.m_size;
  other.m_size = nullptr;
}
```
В приведенном выше коде other - это rvalue.

Перемещающий оператор присваивания обменивает свои поля на его.

**Правило пяти** - реализовать или запретить перемещающий конструктор и move-assignment.

**& - lvalue, && - rvalue**

Можно явно говорить, что lvalue является rvalue.

```C++
array[i]=static_cast<DynamicString &&>(temp)
```
Приведенный выше код - то же самое, что **std::move(temp)**.

std::move использует перемещающий конструктор или оператор присваивания.



